
;;;;;; type reflection

(define type
  (lambda (obj)
   (cond ((eq? (prim-type obj) "userdefined")
          (udt-type obj))
         (true (prim-type obj)))))
       
       
;;;;;; primitive equality
;; i.e. numbers, symbols, strings, booleans, and lists
;; this is kind of like a javascript 'module'
(define equal?
  ((lambda ()
   
    (define eqan?
      (lambda (l r)
       (cond ((eq? (prim-type l) (prim-type r))
              (eq? l r))
             (true false))))
   
    (define list?
      (lambda (s)
       (eqan? "list" (prim-type s))))
   
    (define eqlist?
      (lambda (l r)
       (cond ((null? l) (null? r))         ;; this is like ((and (null? l) (null? r))  true)
             ((null? r) false)             ;; and          ((or  (null? l) (null? r)) false)
             (true (and (prim-equal? (car l) (car r))
                        (prim-equal? (cdr l) (cdr r)))))))
   
    (define prim-equal?
      (lambda (l r)
       (cond ((and (list? l) (list? r))
              (eqlist? l r))
             ((or (list? l) (list? r)) 
              false)
             (true (eqan? l r)))))
            
    prim-equal?)))
;; end of 'equal?' module