
;; a private function
(define table-new
  (lambda (pairs)
   (list "table" pairs)))
   
   
(define table-empty
  (table-new (list)))
  
  
(define first car)

(define second (compose car cdr))
  
  
(define table-get-entries
  (lambda (table)
   (if (not (= (car table) "table"))
       (error "expected table")
       (second table))))
  
  
(define table-has?
  (lambda (table key)
   (= 1 (count
         (filter (lambda (pair)
                   (= (car pair) key))
                 (table-get-entries table))))))
                
                
(define table-add
  (lambda (table key value)
   (if (table-has? table key)
       table
       (table-new (cons (list key value) (table-get-entries table))))))
       
       
(define table-get
  (lambda (table key)
   (if (table-has? table key)
       (second (first (filter (lambda (pair)
                               (= (car pair) key))
                              (table-get-entries table))))
       (error "table does not have key"))))
       
       
(define table-make
  (lambda (pairs)
   (reduce (lambda (t p)
            (table-add t (car p) (car (cdr p))))
           table-empty 
           pairs)))


(define multi-method-table table-empty)

(define add-method
  (lambda (type f)
   (set! multi-method-table 
         (table-add multi-method-table type f))))
   
(define get-method
  (lambda (type)
   (table-get multi-method-table type)))
   
(define has-method?
  (lambda (type)
   (table-has? multi-method-table type)))
   
(add-method "string" =)

(add-method "number" =)

;; 'type' needs to also be a generic function,
;;   so that this can work on user-defined types
;;   as well as the built-in ones
;; suggestion:  change name to 'prim-type' for built-in types
(define ==
  (lambda (l r)
   (if (not (= (type l) (type r)))
       false
       (if (has-method? (type l))
           ((get-method (type l)) l r)
           (error "no method found for this type")))))

