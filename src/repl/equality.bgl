
;; a private function
(define table-new
  (lambda (pairs)
   (list "table" pairs)))
   
   
(define table-empty
  (table-new (list)))
  
  
(define first car)

(define second (compose car cdr))
  
  
(define table-get-entries
  (lambda (table)
   (if (not (eqan? (car table) "table"))
       (error "expected table")
       (second table))))
  
  
(define table-has?
  (lambda (table key)
   (eqan? 1
     (count
      (filter (lambda (pair)
                (eqan? (car pair) key))
              (table-get-entries table))))))
                
                
(define table-add
  (lambda (table key value)
   (if (table-has? table key)
       table
       (table-new (cons (list key value) (table-get-entries table))))))
       
       
(define table-get
  (lambda (table key)
   (if (table-has? table key)
       (second (first (filter (lambda (pair)
                               (eqan? (car pair) key))
                              (table-get-entries table))))
       (error "table does not have key"))))
       
       
(define table-make
  (lambda (pairs)
   (reduce (lambda (t p)
            (table-add t (car p) (car (cdr p))))
           table-empty 
           pairs)))
           
;;;;;;;;

(define eqan?
  (lambda (l r)
   (cond ((eq? (type l) (type r))
          (eq? l r))
         (true false))))

(define list?
  (lambda (s)
   (eqan? "list" (type s))))

(define eqlist?
  (lambda (l r)
   (cond ((null? l) (null? r))         ;; this is like ((and (null? l) (null? r))  true)
         ((null? r) false)             ;; and          ((or  (null? l) (null? r)) false)
         (true (and (equal? (car l) (car r))
                    (equal? (cdr l) (cdr r)))))))

(define equal?
  (lambda (l r)
   (cond ((and (list? l) (list? r))
          (eqlist? l r))
         ((or (list? l) (list? r)) 
          false)
         (true (eqan? l r)))))

;;;;;;;;;;;;;;


(define multi-method-table table-empty)

(define add-method
  (lambda (type f)
   (set! multi-method-table 
         (table-add multi-method-table type f))))
   
(define get-method
  (lambda (type)
   (table-get multi-method-table type)))
   
(define has-method?
  (lambda (type)
   (table-has? multi-method-table type)))
   
(add-method "string" equals?)

(add-method "number" equals?)

(add-method "boolean" equals?)

(add-method "symbol" equals?)

;; 'type' needs to also be a generic function,
;;   so that this can work on user-defined types
;;   as well as the built-in ones
;; suggestion:  change name to 'prim-type' for built-in types
(define =
  (lambda (l r)
   (if (not (equals? (type l) (type r)))
       false
       (if (has-method? (type l))
           ((get-method (type l)) l r)
           (error "no method found for this type")))))

(add-method "list" (eq-list? =))

