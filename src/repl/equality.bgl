
;;;;;; type reflection

(define type
  (lambda (obj)
   (cond ((eq? (prim-type obj) "userdefined")
          (udt-type obj))
         (true (prim-type obj)))))
       
       
;;;;;; primitive equality
;; i.e. numbers, symbols, strings, booleans, and lists
;; this is kind of like a javascript 'module'
(define equal?
  ((lambda ()
   
    (define eqan?
      (lambda (l r)
       (cond ((eq? (prim-type l) (prim-type r))
              (eq? l r))
             (true false))))
   
    (define list?
      (lambda (s)
       (eqan? "list" (prim-type s))))
   
    (define eqlist?
      (lambda (l r)
       (cond ((null? l) (null? r))         ;; this is like ((and (null? l) (null? r))  true)
             ((null? r) false)             ;; and          ((or  (null? l) (null? r)) false)
             (true (and (prim-equal? (car l) (car r))
                        (prim-equal? (cdr l) (cdr r)))))))
   
    (define prim-equal?
      (lambda (l r)
       (cond ((and (list? l) (list? r))
              (eqlist? l r))
             ((or (list? l) (list? r)) 
              false)
             (true (eqan? l r)))))
            
    prim-equal?)))
;; end of 'equal?' module
   
   
   

;;;;;;;;;;;;;; a minimal table
(define eq-funcs
  ((lambda ()
   ;; a private function
   (define table-new
     (lambda (pairs)
      (list "table" pairs)))
      
      
   (define table-empty
     (table-new (list)))
     
     
   (define first car)
   
   (define second (compose car cdr))
     
     
   (define table-get-entries
     (lambda (table)
      (if (not (equal? (car table) "table"))  ;; can maybe replace this with 'type' later
          (table-get-entries-error "expected table")
          (second table))))
     
     
   (define table-has?
     (lambda (table key)
      (equal? 1
        (count
         (filter (lambda (pair)
                   (equal? (car pair) key))
                 (table-get-entries table))))))
                   
                   
   (define table-add
     (lambda (table key value)
      (if (table-has? table key)
          (table-add-error "no!") ;; should be error if it already has it??
          (table-new (cons (list key value) (table-get-entries table))))))
          
          
   (define table-get
     (lambda (table key)
      (if (table-has? table key)
          (second (first (filter (lambda (pair)
                                  (equal? (car pair) key))
                                 (table-get-entries table))))
          (table-get-error "table does not have key"))))
          
          
   (define table-make
     (lambda (pairs)
      (reduce (lambda (t p)
               (table-add t (car p) (car (cdr p))))
              table-empty 
              pairs)))
              
              
   (define table-set
     (lambda (table key value)
      (if (table-has? table key)
          (table-new (cons (list key value)
                           (filter (lambda (pair)
                                    (not (equal? (car pair) key)))
                                   (table-get-entries table))))
          (table-set-error "'table-set': table does not have key"))))
          
          
   (define table-put
     (lambda (table key value)
      (if (table-has? table key)
          (table-set table key value)
          (table-add table key value))))
          
              
   ;;;;;;;;
   
   
   
   (define multi-method-table table-empty)
   
   (define add-method
     (lambda (fname types f)
      (set! multi-method-table 
            (if (not (table-has? multi-method-table fname))
                (table-add multi-method-table 
                           fname
                           (table-add table-empty types f))
                (table-set multi-method-table fname
                  (table-put (table-get multi-method-table fname) types f))))))
      
   (define get-method
     (lambda (fname types)
      (table-get (table-get multi-method-table fname) types)))
      
   (define has-method?
     (lambda (fname types)
      (table-has? (table-get multi-method-table fname) types)))
      
   (add-method "=" "string" equal?)
   
   (add-method "=" "number" equal?)
   
   (add-method "=" "boolean" equal?)
   
   (add-method "=" "symbol" equal?)
   
   
   ;; 'type' needs to also be a generic function,
   ;;   so that this can work on user-defined types
   ;;   as well as the built-in ones
   ;; suggestion:  change name to 'prim-type' for built-in types
   (define =
     (lambda (l r)
      (if (not (equal? (type l) (type r)))
          false
          (if (has-method? "=" (type l))
              ((get-method "=" (type l)) l r)
              (error "no method found for this function and type")))))
   
   ;; wrong -- needs to use '=', not 'equal?' inside of 'eqlist?'
   ;;   anyway, 'eqlist?' is in a different module now, 
   ;;   so this code FAILS
   (add-method "=" "list" eqlist?)
   
   (add-method "<" "number" number-<)
   
   (add-method "<" "boolean" 
     (lambda (l r)
      (if r
          (not l)
          false)))
          
   
   (define <
     (lambda (l r)
      (if (not (equal? (type l) (type r)))
          (<-error "really need to figure this out")
          (if (has-method? "<" (type l))
              ((get-method "<" (type l)) l r)
              (<-error "no method found")))))

    (list = <))))
   ;; this is the end of the 'module':
   ;;    1 ) to end the lambda,
   ;;    2 ) to execute it,
   ;;    3 ) for the 'define'



(define = (car eq-funcs))

(define < (car (cdr eq-funcs)))
       
       
(define <=
  (lambda (l r)
   (or (< l r)
       (= l r))))


(define >
  (lambda (l r)
   (not (<= l r))))
   
   
(define >=
  (lambda (l r)
   (not (< l r))))
   
   
(define !=
  (lambda (l r)
   (not (= l r))))
   
