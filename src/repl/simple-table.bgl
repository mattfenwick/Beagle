
;; the public interface ... yes, global variables are bad
(define st-new false)

(define st-add false)

(define st-has? false)

(define st-get false)

(define st-elems false)

(define st-set false)

(define st-remove false)


;; the implementation
;; IMPORTANT:  still missing 'error' function
((lambda ()
  
   (define constructor (data "simple-table"))
   
   ;; empty :: Simple-Table
   (define empty (constructor (list)))
   
   (define get-pair
     (lambda (table key)
      (define helper
        (lambda (elems)
         (cond ((null? elems) 
                (list))
               ((equal? (car (car elems)) key)
                (car elems))
               (true 
                (helper (cdr elems))))))
      (helper (udt-value table))))
      
   
   ;; has? :: Simple-Table -> key -> Boolean
   (define has?
     (lambda (table key)
      (not (null? (get-pair table key)))))

   
   ;; add :: Simple-Table -> key -> value -> Error Simple-Table
   (define add
     (lambda (table key value)
      (cond ((has? table key)
             (add-error (++ "can't key:  table already has key " key)))
            (true (constructor (cons (list key value)
                                     (udt-value table)))))))


   ;; remove :: Simple-Table -> key -> Error Simple-Table
   (define remove
     (lambda (table key)
      (define helper
        (lambda (pairs)
         (cond ((null? pairs)
                (remove-error (++ "can't remove key " key)))
               ((equal? key (car (car pairs)))
                (cdr pairs))
               (true (cons (car pairs)
                           (helper (cdr pairs))))))) 
      (constructor (helper (udt-value table)))))


   ;; set :: Simple-Table -> key -> value -> Simple-Table
   (define set
     (lambda (table key value)
      (define new-pairs
        (udt-value (cond ((has? table key)
                          (remove table key))
                         (true table))))
      (constructor (cons (list key value) new-pairs))))
      

   ;; get :: Simple-Table -> key -> Error Simple-Table                            
   (define get
     (lambda (table key)
      (define pair (get-pair table key))
      (cond ((null? pair) 
             (get-error (++ "table doesn't have key" key)))
            (true (car (cdr pair))))))
            

   ;; new :: List -> Simple-Table
   (define new
     (lambda (pairs)
      (reduce (lambda (b p)
                (add b (car p) (car (cdr p))))
              empty 
              pairs)))
              

   ;; elems :: Simple-Table -> List
   (define elems
     (lambda (table)
      (udt-value table)))
   

   (set! st-new new)
   
   (set! st-add add)
   
   (set! st-has? has?)
   
   (set! st-get get)

   (set! st-set set)

   (set! st-remove remove)
   
   (set! st-elems elems)))
   
