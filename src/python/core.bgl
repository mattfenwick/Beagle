
{def not
  {fn {x}
    {if x false true}}}

;{def not-test
;  {fn {}
;   (test-ok
;    {and (equals? (not false) true)
;         (equals? (not true)  false)})}}


{def compose
  {fn {f g}
   {fn {x}
    (f (g x))}}}

{def compose-list 
  {fn {fs}
   (reduce compose id fs)}}


;; not written using `reduce` (for now)
;; because that would reverse it
{def map
  {fn {f xs}
    {if (nil? xs)
        []
        (cons (f (car xs))
              (map f (cdr xs)))}}}

; {def map-test
;  {fn {}
;   (test-ok
;    (all 
;     [(eq? (map id []) [])
;      (eq? (map id [1 2 3]) [1 2 3])
;      (eq? (map {fn {x} (cons 4 x)}
;                [[1] [] [3 4]])
;           [[4 1] [4] [4 3 4]])])
;    "map-tests")}}


{def filter
  {fn {f xs}
    {cond {{(nil? xs) []}
           {(f (car xs))
             (cons (car xs) (filter f (cdr xs)))}}
          (filter f (cdr xs))}}}


{def id 
  {fn {x} x}}


{def reduce
  {fn {f b xs}
    {if (nil? xs)
        b
        (reduce f 
           (f b (car xs)) 
           (cdr xs))}}}


{def ||
  {fn {a b}
    {or a b}}}

{def any 
  {fn {vals}
	(reduce || false vals)}}

{def &&
  {fn {a b}
    {and a b}}}

{def all 
  {fn {vals}
	(reduce && true vals)}}


{def zip
  {fn {l1 l2}
    {cond {{(nil? l1) []}
           {(nil? l2) []}}
          (cons [(car l1) (car l2)]
            (zip (cdr l1)
                 (cdr l2)))}}}


{def zip-map
  {fn {f l1 l2}
    (map {fn {p}
           (f (car p) (car (cdr p)))}
         (zip l1 l2))}}
       
       
{def count
  {fn {l}
   (reduce 
    {fn {b n} (+ b 1)}
    0 
    l)}}


{def flip
  {fn {f}
   {fn {a b}
    (f b a)}}}
    
    
{def reverse
  {fn {ls}
   (reduce (flip cons) [] ls)}}


{def ++
  {fn {l1 l2}
   (reduce (flip cons) l2 (reverse l1))}}


{def join-lists
  {fn {x y}
   (reduce ++ []
           (map {fn {e}
                 (map {fn {f} (cons e f)} y)} 
                x))}}
                
                
{def join-many-lists
  {fn {ls}
   (reduce (flip join-lists) [[]] ls)}}
   
   
;{def error
;  {fn {type message trace}
;   (datum "error" [type message trace])}}
   
;; error-type :: Error -> String
;{def error-type
;  {fn {err}
;   (car (value err))}} ;; the 1st elem
   
;; error-message :: Error -> String
;{def error-message
;  {fn {err}
;   (car (cdr (value err)))}} ;; the 2nd elem
   
;; error-trace :: Error -> a
;{def error-trace
;  {fn {err}
;   (car (cdr (cdr (value err))))}} ;; the 3rd elem
   
(print 
  [
   (++ [1 2 3] [4 5 6])
   {and true false}
   {and false true}
   {and false false}
   {and true true}
   {if {or true false} 18 97}
   {if (not true) 109 9999}
   false
   true])

{def x true}
(print x)
{let [[x 3] [y 4]]
  (print x)
  (print y)}
(print x)

;{if 1 2 3}


{def x false}
{set other 34}
{cond {} 14}


{def plus {fn {x y} (+ x y)}}
{if true 3 4}
{if false 3 4}
; (plus 313) ; oops! missing arg -- how should this be detected and reported?
